# 机器人学课设

## 1. 项目简介
本项目基于 MATLAB 和 Simulink 开发，模拟了一个 6 自由度（ZYYZYZ 构型）机械臂进行木琴演奏的全过程。系统能够解析乐谱，自动规划机械臂的运动轨迹，并提供 MATLAB 绘图可视化与 Simulink 3D 仿真环境。



## 2. 核心功能与特性

*   **多曲目支持**: 内置《小星星》、《两只老虎》、《欢乐颂》、《土耳其进行曲》、《花海》、《起风了》、《茉莉花》等多首经典曲目。
*   **仿生运动规划**:
    *   **协同敲击**: 摒弃单一关节运动，采用 **J5 (主)** + **J3 (辅)** + **J2 (辅)** 的多关节协同抬起策略，模拟人类挥臂动作。
    *   **协同移动**: 在水平切换琴键时，采用 **J1 (基座)** + **J4 (腕部旋转)**+**J6 (腕部旋转)** 的混合驱动，优化机械臂姿态，避免单一关节过大运动。
*   **平滑轨迹生成**: 基于梯形速度规划 (Trapezoidal Velocity Profile)，确保所有关节运动同步且平滑，避免冲击。
*   **全功能运动学**: 包含完整的正运动学 (FK) 和逆运动学 (IK) 求解器，支持末端工具（木棒）的精确控制。


## 3. 文件结构说明

| 文件名 | 类型 | 功能描述 |
| :--- | :--- | :--- |
| **`main.m`** | **主程序** | 项目入口。用于设置仿真参数（速度、曲目等）、调用规划器、并进行可视化绘图。 |
| **`GetSong.m`** | **数据** | 曲目数据库。定义了各首歌曲的琴键索引序列和节拍信息。 |
| **`GenerateTrajectory.m`** | **核心算法** | 轨迹规划器。根据乐谱和机器人参数，生成包含时间、位置、速度、加速度的完整轨迹数据。 |
| **`GetStickIK.m`** | **算法** | 针对木棒尖端的逆运动学封装。给定木棒尖端坐标，反解出关节角度。 |
| **`Ikine6s.m`** | **算法** | 6自由度机器人通用的数值/解析逆运动学求解器。 |
| **`Fkine.m`** | **算法** | 通用正运动学求解器 (PoE公式)。 |
| **`GetRobotFK.m`** | **算法** | 正运动学（法兰）。计算机械臂末端法兰盘的位姿。 |
| **`GetJ6Point.m`** | **算法** | 正运动学（工具）。计算安装在法兰上的木棒尖端的位姿。 |
| **`TrapezoidalPlan.m`** | **算法** | 速度规划器。生成梯形速度曲线，实现点到点的平滑运动。 |
| **`test.m` / `test_j6point.m`** | **测试** | 用于验证运动学参数和计算逻辑的测试脚本。 |
| **`trajectory_points.txt`** | **输出** | 仿真生成的关节角度数据文件。 |
| **`sim/`** | **仿真** | 包含 Simulink 模型 (`.slx`)、机器人 STL 模型文件及仿真数据。 |

## 4. 快速开始

### 4.1 环境要求
*   MATLAB R2018b 或更高版本。

### 4.2 运行步骤
1.  打开 MATLAB，将工作目录切换到项目文件夹。
2.  打开 `main.m` 文件。
3.  在“参数设置”区域选择想要演奏的曲目：
    ```matlab
    song_name = 'JasmineFlower'; % 可选: 'LittleStar', 'TwoTigers', 'FlowerSea', 'TheWindRises', 'JasmineFlower' 等
    ```
4.  点击 **运行 (Run)** 按钮。
5.  程序将自动计算轨迹，并弹出以下图表：
    *   **Figure 1**: 3D 空间中的机械臂运动轨迹与琴键位置。
    *   **Figure 2**: 各关节的角度、速度、加速度曲线。
    *   **Figure 3**: 末端法兰在笛卡尔空间的位置和速度。

### 4.3 Simulink 仿真 (可选)
1.  运行 `main.m` 生成轨迹数据。
2.  打开 `sim/HL_0905.slx`。
3.  运行仿真以查看 3D 机械臂演奏效果。

## 5. 参数配置与优化

在 `main.m` 中，您可以调整以下参数来改变演奏风格：

### 5.1 基础参数
*   `tempo`: 演奏速度倍率。`1.0` 为标准速度，`2.0` 为两倍速。
*   `dt`: 仿真时间步长，默认 `0.001` 秒。

### 5.2 优化策略参数
这些参数决定了机器人的“舞姿”：

*   **敲击抬起**:
    *   `params.lift_angle`: **J5 (手腕)** 的抬起角度 (主)。
    *   `params.lift_angle_j3`: **J3 (肘部)** 的协同抬起角度。
    *   `params.lift_angle_j2`: **J2 (肩部)** 的协同抬起角度。
    *   *调整建议*: 增加 J3/J2 的角度可以让动作看起来更舒展，减少 J5 的负担。

*   **水平移动**:
    *   `params.j4_yaw_factor`: **J4 (腕部旋转)** 参与水平移动的比例系数 (0~1)。
    *   `params.j6_roll_factor`: **J6 (工具旋转)** 参与姿态调整的比例系数。
    *   *原理*: 当系数 > 0 时，机器人会通过旋转手腕 (J4) 和工具 (J6) 来改变木棒朝向，从而减少基座 (J1) 的旋转幅度，并增加动作的灵动性。

## 6. 算法原理简述

### 6.1 坐标系定义
*   **基座坐标系 (Base)**: 机器人底座中心。
*   **法兰坐标系 (Flange)**: 第 6 关节末端。
*   **工具坐标系 (Tool)**: 木棒尖端。木棒相对于法兰有固定的平移变换。

### 6.2 轨迹生成流程
1.  **解析乐谱**: 从 `GetSong.m` 获取音符序列。
2.  **逆运动学求解 (IK)**:
    *   对于每个音符，计算木棒击打琴键中心所需的关节角度。
    *   引入 `j4_yaw_factor` 优化目标姿态的偏航角。
3.  **中间点生成**:
    *   在两个音符之间插入“悬停点”。
    *   悬停点在击打点的基础上，叠加 J5, J3, J2 的抬起角度。
4.  **速度规划**:
    *   使用 `TrapezoidalPlan` 在“击打点”和“悬停点”之间生成平滑轨迹。
    *   连接所有片段，形成完整的连续轨迹。

## 7. 核心算法与函数详解

本节将深入代码细节，详细解释每个核心函数的输入输出、内部变量含义、数学推导过程及物理意义。

### 7.1 正运动学求解 (`Fkine.m` / `GetRobotFK.m`)

**文件**: `Fkine.m` (通用求解器), `GetRobotFK.m` (针对本机器人的封装)

*   **数学原理**: **指数积公式 (PoE)**
    $$ T(\theta) = e^{\hat{\xi}_1 \theta_1} e^{\hat{\xi}_2 \theta_2} \dots e^{\hat{\xi}_6 \theta_6} T(0) $$

*   **代码变量解析**:
    *   **输入**:
        *   `Xi` (或代码中的 `x0`): **运动旋量矩阵 (6x6)**。每一列 $i$ 代表第 $i$ 个关节的运动轴参数。
            *   前3行 $v_i = -\omega_i \times q_i$: 线速度部分（由轴线方向和轴上一点确定）。
            *   后3行 $\omega_i$: 角速度部分（轴线单位向量）。
        *   `theta`: 关节角度向量 $[ \theta_1, \dots, \theta_6 ]$。
        *   `g0` (或 `T0`): **初始位姿矩阵 (4x4)**。机器人处于零位（所有角度为0）时，末端法兰相对于基座的变换矩阵。
    *   **内部计算 (`exp_w` 子函数)**:
        *   实现 **罗德里格斯公式** 计算旋转矩阵 $R$：
            $$ R = I + \sin(\|\omega\|\theta) \hat{\omega} + (1 - \cos(\|\omega\|\theta)) \hat{\omega}^2 $$
        *   计算平移向量 $p$：
            $$ p = (I - R)(\omega \times v) + \omega \omega^T v \theta $$
    *   **输出**:
        *   `g_st` (或 `T_flange`): 当前关节角度下的末端位姿矩阵。

*   **为什么这样算**: PoE 公式避免了 D-H 参数建立坐标系时的繁琐和歧义，且对于旋转关节和平移关节有统一的表达形式，计算数值稳定性更好。

### 7.2 逆运动学求解 (`Ikine6s.m`)

**文件**: `Ikine6s.m`

*   **数学原理**: **几何解析法** + **Pieper 准则**
    利用 6 轴机械臂后三轴（J4, J5, J6）交于一点（腕部中心 $P_w$）的特性，将位置和姿态解耦。

*   **计算步骤与变量**:
    1.  **位置解耦 (求 $\theta_1, \theta_2, \theta_3$)**:
        *   **变量**: `T_target` (目标位姿), `L1, L2, L3` (连杆长度)。
        *   **计算**: 首先计算腕部中心 $P_w$ 在基座坐标系下的位置。
            $$ P_w = P_{target} - d_6 \cdot R_{target} \cdot \vec{z} $$
            (代码中通过 `G * pw` 实现，其中 `pw` 是参考点偏移)。
        *   **求解 $\theta_1$**: `t11 = atan2(y, x)`。
        *   **求解 $\theta_2, \theta_3$**: 利用余弦定理。构建由 $L_2, L_3$ 和原点到 $P_w$ 的距离 $r$ 组成的三角形。
            $$ \cos(\alpha) = \frac{L_2^2 + r^2 - L_3^2}{2 L_2 r}, \quad \cos(\beta) = \frac{L_2^2 + L_3^2 - r^2}{2 L_2 L_3} $$
            代码对应 `cal_theta23` 函数。
    2.  **姿态求解 (求 $\theta_4, \theta_5, \theta_6$)**:
        *   **计算**: 计算前三轴产生的旋转 $R_{03}$。
        *   **残差旋转**: 后三轴需要提供的旋转为 $R_{36} = R_{03}^T R_{target}$。
        *   **欧拉角分解**: 将 $R_{36}$ 分解为 **Z-Y-Z 欧拉角**。
            *   $\theta_5 = \text{atan2}(\sqrt{r_{31}^2 + r_{32}^2}, r_{33})$
            *   $\theta_4 = \text{atan2}(r_{23}, r_{13})$
            *   $\theta_6 = \text{atan2}(r_{32}, -r_{31})$
            代码对应 `rotm2zyz` 函数。

*   **输出**: `theta_solutions` (2x6 矩阵)，通常包含“肘上”和“肘下”等多组解。

### 7.3 工具坐标与最优解选择 (`GetStickIK.m`)

**文件**: `GetStickIK.m`

*   **功能**: 连接笛卡尔空间规划与关节空间求解。
*   **关键逻辑**:
    1.  **坐标变换**:
        用户规划的是木棒尖端 $P_{stick}$，但 IK 解算器需要法兰中心 $P_{flange}$。
        $$ P_{flange} = P_{stick} - R_{target} \cdot P_{offset} $$
        变量 `p_j6_xyz = [177.51; 0; 13]` 即为木棒相对于法兰的固定偏移 $P_{offset}$。
    2.  **最优解筛选**:
        IK 会返回多组解（如 $\theta_5$ 为正或负）。为了保证运动连续，避免机械臂“抽搐”，计算所有解与上一时刻角度 `last_q` 的欧氏距离：
        $$ \text{dist} = \| \theta_{curr} - \theta_{last} \| $$
        同时处理 $\pm 2\pi$ 问题（如 $179^\circ$ 到 $-179^\circ$ 实际只差 $2^\circ$），选择距离最小的解。

### 7.4 梯形速度规划 (`TrapezoidalPlan.m`)

**文件**: `TrapezoidalPlan.m`

*   **数学原理**: **S型/梯形速度曲线 (Trapezoidal Velocity Profile)**
    保证速度连续，加速度有界（方波加速度）。

*   **计算流程**:
    1.  **单轴时间计算**:
        对于每个关节 $i$，根据距离 $D_i$、最大速度 $V_{max}$、最大加速度 $A_{max}$ 计算最快完成时间 $T_{min, i}$。
        *   若 $D \cdot A \le V^2$ (距离太短，达不到最大速度): $T = 2\sqrt{D/A}$ (三角形速度剖面)。
        *   否则: $T = D/V + V/A$ (梯形速度剖面)。
    2.  **多轴同步 (Synchronization)**:
        为了让所有关节同时开始、同时结束，取所有关节中最大的时间作为总时间：
        $$ T_{total} = \max(T_{min, 1}, \dots, T_{min, 6}) $$
        并向上取整到时间步长 `dt` 的倍数。
    3.  **参数重算**:
        对于那些原本跑得快的关节，必须“慢下来”配合 $T_{total}$。保持加速度 $A$ 不变（或适当减小），重新计算峰值速度 $V_{new}$：
        $$ V_{new}^2/A - T_{total} V_{new} + D = 0 \implies V_{new} = \frac{T_{total} - \sqrt{T_{total}^2 - 4D/A}}{2} A $$
    4.  **轨迹生成**:
        根据 $t_{acc} = V_{new}/A$，将时间轴分为加速段、匀速段、减速段，分别计算 $q, \dot{q}, \ddot{q}$。

### 7.5 顶层轨迹生成 (`GenerateTrajectory.m`)

**文件**: `GenerateTrajectory.m`

*   **功能**: 它是机器人的“大脑”，负责将抽象的乐谱（音符序列）转化为具体的关节运动指令。它协调了逆运动学求解、姿态优化、动作编排和时间拼接。

*   **输入参数详解**:
    *   `song_keys`: 音符索引数组 (e.g., `[1, 5, 5, 6, ...]`)。
    *   `song_beats`: 节拍数组 (e.g., `[1, 1, 1, 2, ...]`)。
    *   `params`: 核心参数结构体，包含：
        *   `keys_pos`: 所有琴键的笛卡尔坐标 (3x15 矩阵)。
        *   `wrist_center_x`: 虚拟手腕中心 X 坐标，用于计算偏航角。
        *   `wrist_follow_factor`: 虚拟手腕跟随系数 (0~1)。0表示固定中心，1表示中心完全跟随琴键移动。
        *   `lift_angle`, `lift_angle_j3`, `lift_angle_j2`: 各关节抬起幅度。
        *   `j4_yaw_factor`: J4 参与水平旋转的比例。
        *   `v_max_...`, `a_max_...`: 速度和加速度限制。

*   **核心算法流程**:

    1.  **初始化与首个音符准备**:
        *   机器人从 `q_start` (初始姿态) 开始。
        *   计算第一个音符的 `Hover` 点，先移动到那里准备。

    2.  **循环处理每个音符 (The Loop)**:
        对于乐谱中的第 $i$ 个音符：

        *   **步骤 A: 目标姿态计算**
            *   **动态虚拟手腕中心**:
                为了让姿态更自然，虚拟手腕中心 $x_{wc}$ 会跟随目标琴键动态调整：
                $$ x_{wc\_dynamic} = x_{wc\_fixed} + (x_{key} - x_{wc\_fixed}) \cdot k_{follow} $$
                其中 $k_{follow}$ 为 `wrist_follow_factor`。
            *   计算木棒指向琴键的水平偏航角 $\psi_{base}$：
                $$ \psi_{base} = \text{atan2}(y_{key}, x_{key} - x_{wc\_dynamic}) $$
            *   **姿态优化**:
                *   为了减少基座 (J1) 的大幅度摆动并保持运动平滑，算法会在一定范围内搜索最优的工具偏航角 (Yaw) 和滚转角 (Roll)。
                *   **搜索策略**: 在基础偏航角 $\psi_{base}$ 附近尝试不同的偏移量。
                *   **代价函数**: $Cost = w_1 \cdot |q_1| + w_2 \cdot \|q_{curr} - q_{last}\|$。即优先选择 J1 接近 0 度（正对前方）且关节变化小（平滑）的解。
            *   构建目标旋转矩阵 $R_{target}$ 并求解 IK。

        *   **步骤 B: 逆运动学求解 (IK)**
            *   调用 `GetStickIK` 计算击打该琴键所需的关节角 `q_hit_target`。

        *   **步骤 C: 悬停点计算**
            *   为了模拟人类自然的敲击动作，悬停点 **不是** 简单的笛卡尔空间 Z 轴平移，而是 **关节空间的偏移**。
            *   预测下一个音符 $i+1$，计算其击打点 `q_hit_next`。
            *   **动态抬起分配 (`ComputeDynamicLift`)**:
                *   根据目标琴键的距离 (Reach) 和移动跨度 (Move Dist)，动态分配 J2 (肩) 和 J3 (肘) 的抬起角度。
                *   **策略**: 离基座越远或移动跨度越大，越倾向于使用 J2 抬起；近处小范围移动主要靠 J3。
                *   最终悬停姿态：$q_{hover} = q_{hit} + \Delta q_{lift}$。
            *   **物理意义**: 这代表机器人“抬起手准备打下一个音符”的姿态。

        *   **步骤 D: 动作拼接**
            *   **动作 1 (Strike)**: 从 `last_q` (上一个悬停点) -> `q_hit_target` (当前击打点)。使用 `v_max_strike` (高速度)。
            *   **动作 2 (Lift & Move)**: 从 `q_hit_target` -> `q_hover_next` (下一个悬停点)。使用 `v_max_travel` (移动速度)。
            *   这种 **"Hit -> Move to Next Hover"** 的策略消除了中间的停顿，实现了连贯演奏。

    3.  **时间戳累加**:
        *   每次调用 `TrapezoidalPlan` 返回一段轨迹 $(t_{seg}, q_{seg}, \dots)$。
        *   将 $t_{seg}$ 加上当前总时间 $t_{end}$，拼接到总轨迹 `t_all` 中。

*   **设计哲学**:
    *   **Look-Ahead (前瞻)**: 在处理当前音符时，已经计算了下一个音符的悬停点，确保了动作的连续性。
    *   **Joint-Space Heuristics (关节空间启发式)**: 抬起动作在关节空间定义，保证了姿态的自然性（如手肘自然下垂，只抬手腕和前臂）。

## 8. Simulink 仿真说明

项目包含基于 **Simscape Multibody** 的高保真物理仿真模型，用于验证轨迹规划在真实物理环境下的表现。

*   **模型文件**: `sim/HL_0905.slx`
*   **数据文件**: `sim/HL_0905_DataFile.m` (由 CAD 导入生成，包含刚体变换数据)
*   **运行机制**:
    1.  MATLAB 主程序 `main.m` 计算出轨迹数据 `t_all`, `q_all` 等。
    2.  Simulink 模型读取这些工作区变量作为输入信号。
    3.  模型通过 PID 控制器或运动生成器驱动机械臂模型运动，验证轨迹的可行性。

---
*最后更新: 2025-11-20*
